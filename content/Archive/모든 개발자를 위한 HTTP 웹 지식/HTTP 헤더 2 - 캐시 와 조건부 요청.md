---
create: 2024-01-02
---

## 캐시 기본 동작
### 캐시가 없을때

![[Pasted image 20240102220545.png]]
![[Pasted image 20240102220632.png]]

* 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다
* 인터넷 네트워크는 매우 느리고 비싸다
* 브라우저 로딩 속도가 느리다
* 느린 사용자 경험
### 캐시가 있을때

![[Pasted image 20240102220739.png]]
![[Pasted image 20240102220825.png]]
![[Pasted image 20240102220835.png]]

* 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
* 비싼 네트워크 사용량을 줄일수 있다
* 브라우저 로딩속도가 빠르다
* 빠른 사용자 경험 

### 캐시 시간이 초과 할경우 
![[Pasted image 20240102220938.png]]
![[Pasted image 20240102220948.png]]

* 캐시 시간이 초과 하면 , 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다
* 이때 다시 네트워크다


## 검증 헤더와 조건부 요청- 1

### 캐시 시간 초과
* 캐시 유효 시간이 초과해서 서버에 다시 요청 하면 다음 두가지 상황이 존재
	1. 서버에서 기존 데이터 변경
	2. 서버에서 기존 데이터를 변경하지 않음
		* 기존에 다운 받은 캐시 데이터를 재사용 할수 있다. 
		* 하지만 기존의 데이터 와 서버의 데이터가 다르다는 것을 확인할수 있는 방법이 필요
			* ![[Pasted image 20240102221608.png]]![[Pasted image 20240102221716.png]]
				첫번째 요청시 Last-Modified 값을 서버에서 리턴해준 뒤 해당 데이터를 캐시 형태로 저장하고 있다
			* ![[Pasted image 20240102221808.png]]![[Pasted image 20240102221915.png]]![[Pasted image 20240102221949.png]]![[Pasted image 20240102222032.png]]![[Pasted image 20240102222130.png]]
				* 캐시 유효 시간이 초과 해도 , 서버의 데이터가 갱신되지 않으면 
				* 304 Not Modified + 헤더 메타 정보만 응답 이때 Body 값은 없다
				* 클라이언트는 서버에서 보낸 응답 헤더 정보로 캐시 메타 정보를 갱신
				* 클라이언트는 해당 캐시 정보를 재사용 
				* 결과적으로 네트워크 다운로드는 발생하지만 Body 값은 없기 때문에 기존 요청보다 훨씬 빠른 속도


## 검증 헤더와 조건부 요청 -2 
* 검증 헤더
	* 캐시데이터와 서버 데이터가 같은지 검증하는 데이터
	* Last-Modified , ETag
* 조건부 요청 헤더
	* 검증 헤더로 조건에 따른 분기
	* if-Modified-Since  : Last-Modified 사용
		* 데이터 미 변경시 예시
			* 캐시 2020 년 11 월 10 일 10:00  vs 서버 : 2020 년 11월 10 일 10:00 
				* 304  Not Modified 반환 
				* 전송 용량 0.1 M (헤더 값 , Body X)
		* 데이터 변경시
			* 2020 년 11 월 10 일 10:00  vs 서버 : 2020 년 11월 10 일 **11:00**
				* 200 OK 모든 데이터 전송
				* 전송 용량 1.1M (헤더값 , Body 값)
		* 단점
			* 1초 미만으로 단위 캐시 조정 불가능
			* 날짜 기반의 로직 사용
			* 데이터를 수정 해서 날짜가 다르지만 같은 데이터를 수정해서 결과가 똑같은 경우 
			* 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
				* 예) 스페이스나 주석 처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우 
	* if-None-Match : ETag (Entity Tag)
		* 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
			* 예)ETag : "V1.0" , ETag:"a2jiodwjeki3"
		* 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash 를 다시 생성)
			* 예) ETag: "aaaaa" -> ETag:"bbbb"
		* 단순하게 Etag 만 보내서 같으면 유지 다르면 새로 다운로드
		* ![[Pasted image 20240102223822.png]]![[Pasted image 20240102223841.png]]![[Pasted image 20240102223859.png]]![[Pasted image 20240102223925.png]]![[Pasted image 20240102223946.png]]
			* 캐시 제어 로직을 서버에서 완전히 관리
			* 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
			* 예)
				* 서버는 베타 오픈 기간인 3일동안 파일이 변경되도록 ETag 를 동일하게 유지
				* 애플리 케이션 배포 주기에 맞춘 갱신
	* 조건이 만족하면 200 
	* 조건이 만족하지 않으면 304 Not Modified

## 캐시 와 조건부 요청 헤더

### 캐시
* Cache-Control : 캐시 제어
	* Cache-Control : max-age
		* 캐시 유효기간 , 초 단위
	* Cache-Control: no-cache
		* 데이터는 캐시해도 되지만 항상 origin 서버에서 검증하고 사용
	* Cache-Control: no-store
		* 데이터에 민감한 정보가 있으므로 저장하면 안됨
			* 메모리에서 사용하고 최대한 빨리 삭제
* Prama : 캐시제어 (하위 호환)
* Expires : 캐시 유효기간(하위 호환)
	* 캐시 만료일을 정확한 날짜로 지정
	* HTTP 1.0 부터 사용
	* 지금은 더 유연한 Cache-Control : max-age 를 권장
	* 현재는 Cache-Control : max-age 와 Expires 사용시 Expires 무시
### 요청헤더
* ![[Pasted image 20240102224639.png]]


## 프록시 캐시

![[Pasted image 20240102225134.png]]![[Pasted image 20240102225203.png]]
![[Pasted image 20240102225440.png]]

* 프록시 캐시 사용시 기존 원(Origin) 서버 가 아닌 한국 어딘가에 존재하는 캐시 서버(CDN?)에 요청
* Cache-Control : public 
	* 응답이 public 캐시에 저장되어도 됨
	* 예)
		* 구글 아이콘은 Public 캐시에 저장되어도됨 
			* ![[Pasted image 20240102225859.png]]
*  Cache-Control : private
	* 응답이 해당 사용자 만을 위한 것임 , private 캐시에 저장해야함
	* 예)
		* 구글 로고는 Private 캐시임 (Why?)
		* ![[Pasted image 20240102230008.png]]
*  Cache-Control : s-maxage
	* 프록시 캐시에만 사용되는 max-age
* Age:60
	* 오리진 서버에서 응답후 프록시 캐시 내에 머문 시간

## 캐시 무효화
* 확실한 캐시 무효화 응답
* Cache-Control: no-cache
	* 데이터는 캐시는 사용해도 되지만 항상 원(Origin) 서버에서 검증하고 사용
	* ![[Pasted image 20240102230554.png]]![[Pasted image 20240102230649.png]]
		* no-cache 설정시 반드시 원 서버에서 검증을 거쳐야 한다. 하지만 알수없는 오류로 인해 원 서버에 접근이 불가할 경우 이때는 프록시 캐시에 있는 데이터를 보여 줌으로서 오류를 방지한다 ^5c9dfc
* Cache-Control: no-store
	* 데이터에 민감한 정보가 있으므로 저장하면 안됨
* Cache-Control:  must-revalidate
	* 캐시 만료후 최초 조회시 원 서버에 검증
	* 원 서버 접근 실패시 반드시 오류가 발생해야함
	* must-revalidate 는 캐시 유효 시간이라면 캐시 사용
	* ![[Pasted image 20240102230755.png]]
		* must-revalidate 는 ![[HTTP 헤더 2 - 캐시 와 조건부 요청#^5c9dfc]] no-cache 와 다르게 원 서버에 장애가 발생할경우 프록시 캐시 도 오류를 반환 하여 504 Gateway Timeout 을 보여준다
* Pragma: no-cache
	* HTTP 1.0 하위 호환
* ![[Pasted image 20240102230449.png]]
	* 캐시를 완전히 무효화 하기 위해서는 위에 있는 이미지 처럼 전부 설정해줘야한다